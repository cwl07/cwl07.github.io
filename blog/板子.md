# 板子

### 数据结构

#### 并查集

```cpp
struct DSU
{
    int *fa;
    int N;
    
    DSU(int n)
    {
        N = n + 10;
        fa = (int*)malloc(N*sizeof(int));
        for(int i=1;i<=n;++i)
        	fa[i] = i;
    }
    virtual ~DSU()
    {
        free(fa);fa=NULL;
    }
    int get(int x)
    {
        if(fa[x]==x)
        	return x;
       	return fa[x] = get(fa[x]);
    }
    inline void merge(int x, int y)
    {
        int rtx = get(x);
        int rty = get(y);
        if(rtx==rty)
        	return ;
        fa[rtx] = rty;
        return ;
    }
};
```

###### 复杂度

`DSU(int n);`  -> $O(N)$

`get(int x);`  -> $O(logN)$

`merge(int x, int y);`  -> $O(logN)$



#### 树状数组

```cpp
template<typename T>
struct BIT
{
    T *c;
    int N;
    
    BIT(int n)
    {
        N = n + 10;
        c = (T*)calloc(N, sizeof(T));
    }
    ~BIT()
    {
        free(c);c=NULL;
    }
    void add(int x, T y)
    {
        for(;x<N;x+=(x&(-x)))c[x] += y;
    }
    T ask(int x)
    {
        T ans = 0;
        for(;x;x-=(x&(-x)))ans += c[x];
        return ans;
    }
};
```

**将add()和ask()内的for互换可改为求后缀**

###### 复杂度

`add(int x, T y);`  -> $O(logN)$

`ask(int x);`  -> $O(logN)$



#### 线段树

```cpp
struct SegmentTree
{
    struct Node
    {
        Node *lson, *rson;
        ll data;
        ll plus;

        Node()
        {
            lson = NULL;rson = NULL;
            data = plus = 0;
        }
        inline void update(const Node& lson, const Node& rson)
        {
            data = lson.data + rson.data;
            return;
        }
    };
    Node* root;
    int dl, dr;
    Node *pool;int pool_tot;

    SegmentTree(int l, int r)
    {
        dl = l;dr = r;
        root = new Node;
        createPool((r - l + 1 + 10)<<1);pool_tot = 0;
    }
    virtual ~SegmentTree()
    {
        delete[] pool;pool=NULL;
        delete root;root=NULL;
    }
    void createPool(int num)
    {
        pool = new Node[num];
    }
    Node* newNode()
    {
        return pool+(++pool_tot);
    }
    void build(Node& rt, int l, int r, const ll *arr)
    {
        if(l==r)
        {
            rt.data = arr[l];
            return;
        }
        int mid = ((l + r) >> 1);
        rt.lson = newNode();
        rt.rson = newNode();
        build(*rt.lson, l, mid, arr);
        build(*rt.rson, mid+1, r, arr);
        rt.update(*rt.lson, *rt.rson);
    }
    void spread(Node& rt, int l, int r)
    {
        (*rt.lson).plus += rt.plus;
        (*rt.rson).plus += rt.plus;
        int mid = ((l + r) >> 1);
        (*rt.lson).data += (ll)(mid - l + 1ll) * rt.plus;
        (*rt.rson).data += (ll)(r - mid) * rt.plus;
        rt.plus = 0;
    }
    void range_change(Node& rt, int l, int r, int ql, int qr, const ll& plus)
    {
        if(l==ql&&r==qr)
        {
            rt.plus += plus;
            rt.data += (ll)(r - l + 1ll) * plus;
            return;
        }
        spread(rt, l, r);
        int mid = ((l + r) >> 1);
        if(qr<=mid){range_change(*rt.lson, l, mid, ql, qr, plus);}
        else if(ql>mid){range_change(*rt.rson, mid+1, r, ql, qr, plus);}
        else 
        {
            range_change(*rt.lson, l, mid, ql, mid, plus);
            range_change(*rt.rson, mid+1, r, mid+1, qr, plus);
        }
        rt.update(*rt.lson, *rt.rson);
    }
    ll range_query(Node&rt, int l, int r, int ql, int qr)
    {
        if(l==ql&&r==qr)
        {
            return rt.data;
        }
        spread(rt, l, r);
        int mid = ((l + r) >> 1);
        if(qr<=mid){return range_query(*rt.lson, l, mid, ql, qr);}
        else if(ql>mid){return range_query(*rt.rson, mid+1, r, ql, qr);}
        else
        {
            return range_query(*rt.lson, l, mid, ql, mid) + range_query(*rt.rson, mid+1, r, mid+1, qr);
        }
    }
};
```

**以上为动态开点线段树的例子，以 洛谷P3372 为例 。实际应用中线段树灵活性强，需要结合题意设计**

**以上例子使用了内存池 实测用new开辟会慢一些**

###### 复杂度

`build(Node& rt, int l, int r, const ll *arr);`  -> $O(N)$

`spread(Node& rt, int l, int r);`  -> $O(1)$

`range_change(Node& rt, int l, int r, int ql, int qr, const ll& plus);`  -> $O(logN)$

`range_query(Node&rt, int l, int r, int ql, int qr);`  -> $O(logN)$



### 杂项

#### 离散化

```cpp
template<typename T>
struct Discrete
{
    std::vector<T> data;

    inline void add(T x){data.push_back(x);}
    inline void discrete()
    {
        std::sort(data.begin(), data.end());
        data.resize(std::unique(data.begin(), data.end()) - data.begin());
    }
    inline int id(T x){return std::lower_bound(data.begin(), data.end(), x) - data.begin() + 1;}
    inline T val(int id){return data[id - 1];}
};
```

###### 复杂度

`add(T x);`  -> $O(1)$

`discrete()`  -> $O(NlogN)$

`id(T x)`  -> $O(logN)$

`val(int id)`  -> $O(1)$

**此模板离散化后的值下标从 $1$ 开始**



#### 最值

```cpp
template<typename T> inline T wlmin(T a, T b){return (a<b)?a:b;}
template<typename T> inline T wlmax(T a, T b){return (a<b)?b:a;}
```

###### 复杂度

均为 $O(1)$

